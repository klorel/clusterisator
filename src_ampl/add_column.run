
if card(COLS)<-1 then{
	if USE_IPS == 0 then
		include ips_q.run;
	let Q_Z_COL := 
		setof{(__new_col, __cost, __rc) in POOL_COST, x_z in Z: __rc>ZERO_REDUCED_COST}(
			__new_col, x_z, 0+sum{(__new_col, v) in POOL_SOLUTION, (x_z, v, value) in Q_Z}value
		);
	let COL_COMPATIBLE := {(__new_col, __cost, __rc) in POOL_COST:  __rc>ZERO_REDUCED_COST and max{(__new_col, col_z, val) in Q_Z_COL}abs(val) <= 1e-6};
#	display {(__new_col, __cost, __rc) in POOL_COST: max{(__new_col, col_z, val) in Q_Z_COL}abs(val) > 1e-6}max{(__new_col, col_z, val) in Q_Z_COL}abs(val);
	printf "uncompatible columns : %8d\n", card({(__new_col, __cost, __rc) in POOL_COST: __rc>ZERO_REDUCED_COST and max{(__new_col, col_z, val) in Q_Z_COL}abs(val) > 1e-6});
	printf "  compatible columns : %8d\n", card(COL_COMPATIBLE);
#	exit;
};

let CG_ADDED := card(COLS);

let COLS := COLS union setof{(__new_col, __cost, __rc) in POOL_COST: __rc>ZERO_REDUCED_COST}(CG_ADDED+__new_col);

let ALL_COST := ALL_COST union setof{(__new_col, __cost, __rc) in POOL_COST: __rc>ZERO_REDUCED_COST}(CG_ADDED+__new_col, __cost, __rc);

let ALL_COLUMNS := ALL_COLUMNS union 
setof{(__new_col, __cost, __rc) in POOL_COST, (__new_col, __v) in POOL_SOLUTION: __rc>ZERO_REDUCED_COST}(CG_ADDED+__new_col, __v);

let CG_ADDED := card({(__new_col, __cost, __rc) in POOL_COST: __rc>ZERO_REDUCED_COST});

#display POOL_COST;