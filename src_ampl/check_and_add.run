if USE_STAB=0 then{
	if CG_SUCCESS> 0 then{
		#include add_column.run;
	}else{
		let CG_STOP := 1;
	};
}else{
	if CG_SUCCESS > 0  then {
		if CG_SUCCESS > 0 and STEP != 'EXACT' then{
			# we cannot check for SS or NS as EXACT was not called
			let BUNDLE_STEP := 'XS';		
		}else{			

		};
			
		if USE_STAB != 0 then{
			let PHI_PI := PI_DOT_B + FAKE_RHS*CG_REDUCED_COST;
			
			let SCORE := (PHI_PI - PHI_PI_BAR) - M*(PHI_B_PI - PHI_PI_BAR);
		
			
			# we can check for SS or NS as EXACT was called
			if SCORE <= 0 or AT_LEAST_ONE_SS == 0 then{
				if USE_STAB == 1 then
					let{v in V}CENTER[v] := PI[v];
				else
					let{v in V}CENTER[v] := FEAS_V[v];
				let BUNDLE_STEP := 'SS';
				let PHI_PI_BAR := PHI_PI;
				
				let NB_SS := NB_SS+1;
				let NB_NS := 0;
				let AT_LEAST_ONE_SS := 1;
				
			}else{
				let BUNDLE_STEP := 'NS';
				let NB_NS := NB_NS+1;
				let NB_SS := 0;
			};	
			
			if NB_NS >= 800 then{
				let NB_NS := 0;
				let PARAM_PENALTY := PARAM_PENALTY * 2;
		#		display PARAM_PENALTY;
				let BUNDLE_STEP := '+NS';
			};
			if NB_SS >= 800 then{
				let NB_SS := 0;
				let PARAM_PENALTY := PARAM_PENALTY * 0.5;
				let BUNDLE_STEP := '-SS';
		#		display PARAM_PENALTY;
			};
		};
	}else{
		if FEAS_ERROR <= 1e-6 then
			let CG_STOP := 1;
		else{
			let PARAM_PENALTY := PARAM_PENALTY * 0.5;
			if USE_STAB == 2 then{
				let{v in V} CENTER[v] :=  (CENTER[v])/2;
			};
			display PARAM_PENALTY;
			let BUNDLE_STEP := '-FEAS';
		};
	};
};
if 1=0 then{
	if card({v in V:abs(PI[v]-CENTER[v])<1e-6 and sum{i in 1..N_BRANCHES}+dual_pos[v, i] > 1e-6})>0 then 
		printf "NB IN_POS %6d\n", card({v in V:abs(PI[v]-CENTER[v])<1e-6 and sum{i in 1..N_BRANCHES}+dual_pos[v, i] > 1e-6});
	if card({v in V:abs(PI[v]-CENTER[v])<1e-6 and sum{i in 1..N_BRANCHES}+dual_neg[v, i] > 1e-6})>0 then 
		printf "NB IN_NEG %6d\n", card({v in V:abs(PI[v]-CENTER[v])<1e-6 and sum{i in 1..N_BRANCHES}+dual_neg[v, i] > 1e-6});
	
		if card({v in V:abs(PI[v]-CENTER[v])<1e-6 and sum{i in 1..N_BRANCHES}+dual_pos[v, i] > 1e-6})>0 then 
			display{v in V:abs(PI[v]-CENTER[v])<1e-6 and sum{i in 1..N_BRANCHES}+dual_pos[v, i] > 1e-6}('IN_POS', Z_POS_FACTOR[v] * 0.5);
		if card({v in V:abs(PI[v]-CENTER[v])<1e-6 and sum{i in 1..N_BRANCHES}+dual_neg[v, i] > 1e-6})>0 then 
			display{v in V:abs(PI[v]-CENTER[v])<1e-6 and sum{i in 1..N_BRANCHES}+dual_neg[v, i] > 1e-6}('IN_POS', Z_NEG_FACTOR[v] * 0.5);
	
	let{v in V:abs(PI[v]-CENTER[v])<1e-6 and sum{i in 1..N_BRANCHES}+dual_pos[v, i] > 1e-6} Z_POS_FACTOR[v] := Z_POS_FACTOR[v] * 0.5;
	let{v in V:abs(PI[v]-CENTER[v])<1e-6 and sum{i in 1..N_BRANCHES}+dual_neg[v, i] > 1e-6} Z_NEG_FACTOR[v] := Z_NEG_FACTOR[v] * 0.5;

};

if 1=0 then{
	if card({v in V : dual_pos[v, N_BRANCHES] > 1e-6}) >0 then
		display{v in V : dual_pos[v, N_BRANCHES] > 1e-6}('OUT_POS',  Z_POS_FACTOR[v] * 2);
		
	if card({v in V : dual_neg[v, N_BRANCHES] > 1e-6}) >0 then
		display{v in V : dual_neg[v, N_BRANCHES] > 1e-6}('OUT_NEG', Z_NEG_FACTOR[v] * 2);
	
	let{v in V : dual_pos[v, N_BRANCHES] > 1e-6}Z_POS_FACTOR[v] := Z_POS_FACTOR[v] * 2;
	let{v in V : dual_neg[v, N_BRANCHES] > 1e-6}Z_NEG_FACTOR[v] := Z_NEG_FACTOR[v] * 2;
};
#display OPT_ERROR ;
#if OPT_ERROR < 1e-1 then{
#			let PARAM_PENALTY := PARAM_PENALTY * 0.5;
#			display PARAM_PENALTY;
#			};
#if 1==0 then{
#	if CG_SUCCESS > 0 then {
#		include add_column.run;		
#		if CG_SUCCESS > 0 and STEP != 'EXACT' then{
#			# we cannot check for SS or NS as EXACT was not called
#			let BUNDLE_STEP := 'XS';		
#		}else{			
#
#		};
#	}else{
#		# launch exact only is feasibility is near 0
#		if CG_STEP == 'VNS' then{
#			if FEAS_ERROR >= 1e-6 then 
#				let PARAM_PENALTY := PARAM_PENALTY * 0.5;
#			else
#				let CG_STEP := 'VNS_FEAS';
#		}else{
#			if FEAS_ERROR <= 1e-6 then
#				let CG_STOP := 1;
#			else{
#				let PARAM_PENALTY := PARAM_PENALTY * 0.5;
#			}			
#		};
#	};
#};