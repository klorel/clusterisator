include main.run;
include read_E.run;
include init.run;

param IPS_ITE	default 0;
param IPS_PI{V}	default 0;
param IPS_STOP	default 0;
param IPS_N 	default 0;

problem IPS_PRICING: x;

subject to ips_compatibility{x_z in Z}: +sum{(x_z, v, value) in Q_Z, (col, v) in ALL_COLUMNS}value*x[col];

subject to ips_convexity: +sum{col in COLS}x[col] = 1;

maximize IPS_REDUCED_COST: +sum{(col, cost, rc) in ALL_COST}(cost - sum{(col, v) in ALL_COLUMNS}IPS_PI[v])*x[col];

problem DEFAULT;

display V;
display R;
display B;
display card(V);
display card(E);

let CG_STOP := 0;
let CG_ITE := 0;

let USE_IPS := 1;

printf "%6s%6s%6s%6s%8s%17s%17s", "IPS", "CG", "COLS", "ADDED", "STEP", "BOUND", "IPS_OBJ", "RC";
printf "\n";
repeat{
	let IPS_ITE := IPS_ITE + 1;
	###########################################################################
	# UPDATE the basis
	###########################################################################
	problem master;

	let DISPLAY_MASTER_SOLVE := 0;
	option cplex_options 'outlev=1 mipdisplay=2 lpdisplay=1 threads=1 dualopt';
	let DISPLAY_MASTER_SOLVE := 1;
	if DISPLAY_MASTER_SOLVE == 1 then{
		solve MASTER_OBJ;
	}else{
		close master.log;
		solve MASTER_OBJ > master.log;
	};
	if solve_result != 'solved' then { display solve_result;exit;};
	
	let{v in V} IPS_PI[v] := set_partitionning[v].dual;
	display x.sstatus;
	include ips_q.run;
	# fix uncompatible column
	display Q_Z;

	let CG_BOUND := c_dot_x;
	
	let POOL_COST := {};
	let POOL_SOLUTION  := {};
	let STEP := "UNKNOWN";
	
	let CG_ADDED := 0;
	###########################################################################
	let CG_ITE := 0;
	let CG_STOP := 0;
#	display IPS_PI;
	
	repeat{
		let IPS_N := card(COLS);
				
		let CG_ITE := CG_ITE + 1;

		###########################################################################
		# GENERATE columns maximizing the reduced cost
		###########################################################################
		problem IPS_PRICING;

		let DISPLAY_MASTER_SOLVE := 0;
		option cplex_options 'outlev=1 mipdisplay=2 lpdisplay=1 threads=1 dualopt';
		if DISPLAY_MASTER_SOLVE == 1 then{
			solve IPS_REDUCED_COST;
		}else{
			close master.log;
			solve IPS_REDUCED_COST > master.log;
		};
		if solve_result != 'solved' then { display solve_result;exit;};
		
		let{v in V} PI[v] := IPS_PI[v]+sum{(x_z, v, value) in Q_Z}value*ips_compatibility[x_z];
		
		let CG_BOUND := c_dot_x;
		
		let POOL_COST := {};
		let POOL_SOLUTION  := {};
		let STEP := "UNKNOWN";
		
		let CG_ADDED := 0;
		###########################################################################
		include slave_exact.run;
		problem DEFAULT;		
		include check_and_add.run;
		let CG_ADDED := card({(__new_col, __cost, __rc) in POOL_COST: __rc>ZERO_REDUCED_COST});
		problem DEFAULT;
		printf "%6d%6d%6d%6d%8s%17.8E%17.8E%17.8E", IPS_ITE, 	CG_ITE, CG_COLS, CG_ADDED, STEP, CG_BOUND, IPS_REDUCED_COST, CG_REDUCED_COST;
		printf "\n";
		if CG_STOP != 1 then{
			include add_column.run;		
		}else{
#			display {col in COLS:x[col]>1e-8}x[col];
		};
#		if IPS_OBJ > ZERO_REDUCED_COST or CG_ITE > 1000 then let CG_STOP := 1;
	} until CG_STOP == 1;
}until IPS_STOP == 1;