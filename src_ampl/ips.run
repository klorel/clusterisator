include main.run;
data;
set E := include ../txt/divorces.txt;
model;

include init.run;

param IPS_ITE	default 0;
param IPS_PI{V}	default 0;
param IPS_STOP	default 0;
param IPS_N 	default 0;
problem master;

maximize IPS_OBJ: sum{(col, cost, rc) in ALL_COST}(cost - sum{(col, v) in ALL_COLUMNS}IPS_PI[v]*0)*x[col];
	
problem DEFAULT;

display V;
display R;
display B;
display card(V);
display card(E);

let CG_STOP := 0;
let CG_ITE := 0;

let USE_IPS := 1;

printf "%6s%6s%6s%6s%8s%17s%17s", "IPS", "CG", "COLS", "ADDED", "STEP", "BOUND", "IPS_OBJ", "RC";
printf "\n";
repeat{
	let IPS_ITE := IPS_ITE + 1;
	###########################################################################
	# UPDATE the basis
	###########################################################################
	problem master;
	unfix x;

	let DISPLAY_MASTER_SOLVE := 0;
	option cplex_options 'outlev=1 mipdisplay=2 lpdisplay=1 threads=1 dualopt';
	
	if DISPLAY_MASTER_SOLVE == 1 then{
		solve MASTER_OBJ;
	}else{
		close master.log;
		solve MASTER_OBJ > master.log;
	};
	if solve_result != 'solved' then { display solve_result;exit;};
	
#	display {col in COLS: x[col]>1e-6}x[col];
	
	let{v in V} IPS_PI[v] := set_partitionning[v].dual;
	
	include ips_q.run;
	# fix uncompatible column
	display Q;
#	fix{(col, cost, rc) in ALL_COST: max{col_z in Z}abs(0+sum{(col_z, col_v) in NZ_Q}Q[col_z, col_v])>1e-6}x[col] := 0;
	
	#fix{(col, cost, rc) in ALL_COST:x[col].sstatus!='bas'}x[col];
	#fix{(col, cost, rc) in ALL_COST:x[col] <= 1e-6}x[col];
	#	fix;
	#	let{(col, cost, rc) in ALL_COST:x[col].sstatus=='bas' and x[col]>1e-6}LB[col] := -Infinity;
	
#	display {(col, cost, rc) in ALL_COST:x[col].sstatus!='bas'}(cost - sum{(col, v) in ALL_COLUMNS}IPS_PI[v]);
#	display card({(col, cost, rc) in ALL_COST:x[col].sstatus=='bas'});
#	display card({(col, cost, rc) in ALL_COST:x[col].sstatus=='bas' and x[col] <= 1e-6});
#	display card({(col, cost, rc) in ALL_COST:x[col].sstatus=='bas' and x[col] > 1e-6});
	
 #	exit;
	let CG_BOUND := c_dot_x;
	
	let POOL_COST := {};
	let POOL_SOLUTION  := {};
	let STEP := "UNKNOWN";
	
	let CG_ADDED := 0;
	###########################################################################
	let CG_ITE := 0;
	let CG_STOP := 0;
#	display IPS_PI;
	repeat{
		let IPS_N := card(COLS);
	#display x.sstatus;
		let CG_ITE := CG_ITE + 1;
		###########################################################################
		# GENERATE columns maximizing the reduced cost
		###########################################################################
		problem master;
		let DISPLAY_MASTER_SOLVE := 0;
		option cplex_options 'outlev=1 mipdisplay=2 lpdisplay=1 threads=1 dualopt';
		if DISPLAY_MASTER_SOLVE == 1 then{
			solve IPS_OBJ;
		}else{
			close master.log;
			solve IPS_OBJ > master.log;
		};
		if solve_result != 'solved' then { display solve_result;exit;};
		
		let{v in V} PI[v] := set_partitionning[v].dual + 0*IPS_PI[v];
		
		let OPT_ERROR := max{v in V}abs(CENTER[v]-PI[v]);
		
		let CG_BOUND := c_dot_x;
		
		let POOL_COST := {};
		let POOL_SOLUTION  := {};
		let STEP := "UNKNOWN";
		
		let CG_ADDED := 0;
		###########################################################################
		problem DEFAULT;
			
		# exact pricing if heuristic failed	
		if CG_SUCCESS == 0 then{
			include slave_exact.run;
			problem DEFAULT;
			
		};
		
		include check_and_add.run;
		let CG_ADDED := card({(__new_col, __cost, __rc) in POOL_COST: __rc>ZERO_REDUCED_COST});
		problem DEFAULT;
		printf "%6d%6d%6d%6d%8s%17.8E%17.8E%17.8E", IPS_ITE, 	CG_ITE, CG_COLS, CG_ADDED, STEP, CG_BOUND, IPS_OBJ, CG_REDUCED_COST;
		printf "\n";
		if CG_STOP != 1 then{
			include add_column.run;		
		}else{
#			display {col in COLS:x[col]>1e-8}x[col];
		};
#		if IPS_OBJ > ZERO_REDUCED_COST or CG_ITE > 1000 then let CG_STOP := 1;
	} until CG_STOP == 1;
}until IPS_STOP == 1;