
reset;

param nR integer > 0;
param nB integer > 0;


set V1 := {(i,j) in  1..nR cross 1..nB };

set V2 := V1 cross V1;
set V3 := {(i,j,k) in  V1 cross 1..nB };

set E within {(i,j) in V1 };

param a{(i,j) in V1} :=  if ((i,j) in E ) then 1.0 else 0.0;

param kR{ i in 1..nR } := card({(i,j) in E});
param kB{ j in 1..nB } := card({(i,j) in E});

param m := 1.0*card(E);
param inv_m := 1.0/m;

param w{(i,j) in V1 } := (a[i,j]-kR[i]*kB[j]*inv_m)*inv_m;

# data divorces2.dat;
data social_work.dat;
# data women.dat;



# display E;
# display k;
display E;
# display w;
# display V2;
# display V3;

var x{V1} binary;

param activate1{ (iR,iB,jR,jB) in V2} default 0;
param activate2{ (iR,iB,jR,jB) in V2} default 0;
param activate3{ (iR,iB,jR,jB) in V2} default 0;
param activate4{ (iR,iB,jR,jB) in V2} default 0;

maximize modularity: sum{(i,j) in V1} w[i,j]*x[i,j];

subject to ctr1 { (iR,iB,jR,jB) in V2} : activate1[iR,iB,jR,jB]*(+x[iR,iB]+x[iR,jB]+x[jR,iB]-x[jR,jB])<=2;
subject to ctr2 { (iR,iB,jR,jB) in V2} : activate2[iR,iB,jR,jB]*(+x[iR,iB]+x[iR,jB]-x[jR,iB]+x[jR,jB])<=2;
subject to ctr3 { (iR,iB,jR,jB) in V2} : activate3[iR,iB,jR,jB]*(+x[iR,iB]-x[iR,jB]+x[jR,iB]+x[jR,jB])<=2;
subject to ctr4 { (iR,iB,jR,jB) in V2} : activate4[iR,iB,jR,jB]*(-x[iR,iB]+x[iR,jB]+x[jR,iB]+x[jR,jB])<=2;

# subject to ctr2 { (i,j,k,l) in V2} : +x[i,j]-x[k,j]-x[i,k]<=1;
# subject to ctr3 { (i,j,k,l) in V2} : -x[i,j]+x[k,j]-x[i,k]<=1;

# subject to ctr4 { (i,j,k) in V3} : +x[i,j]+x[j,k]-x[i,k]<=1;
# subject to ctr5 { (i,j,k) in V3} : +x[i,j]-x[j,k]-x[i,k]<=1;
# subject to ctr6 { (i,j,k) in V3} : -x[i,j]+x[j,k]-x[i,k]<=1;
# subject to ctr2 { (r,s,t) in V3} : +x[r,s]-x[s,t]+x[r,t]<=1;
# subject to ctr3 { (r,s,t) in V3} : -x[r,s]+x[s,t]+x[r,t]<=1;

option solver xpress;
option xpress_options "outlev=1";

param go_on;
param violated_cuts1;
param violated_cuts2;
param violated_cuts3;
param violated_cuts4;



repeat 
{
	solve modularity;
	let violated_cuts1 := card({ (iR,iB,jR,jB) in V2 : +x[iR,iB]+x[iR,jB]+x[jR,iB]-x[jR,jB]>2});
	let violated_cuts2 := card({ (iR,iB,jR,jB) in V2 : +x[iR,iB]+x[iR,jB]-x[jR,iB]+x[jR,jB]>2});
	let violated_cuts3 := card({ (iR,iB,jR,jB) in V2 : +x[iR,iB]-x[iR,jB]+x[jR,iB]+x[jR,jB]>2});
	let violated_cuts4 := card({ (iR,iB,jR,jB) in V2 : -x[iR,iB]+x[iR,jB]+x[jR,iB]+x[jR,jB]>2});
	
	display violated_cuts1, violated_cuts2, violated_cuts3, violated_cuts4;
	
	if(violated_cuts1>0) then 
		let{ (iR,iB,jR,jB) in V2} activate1[iR,iB,jR,jB] := if(+x[iR,iB]+x[iR,jB]+x[jR,iB]-x[jR,jB]>2) then 1 else activate1[iR,iB,jR,jB] ;
	else if(violated_cuts2>0) then 
		let{ (iR,iB,jR,jB) in V2} activate2[iR,iB,jR,jB] := if(+x[iR,iB]+x[iR,jB]-x[jR,iB]+x[jR,jB]>2) then 1 else activate2[iR,iB,jR,jB] ;
	else if(violated_cuts3>0) then 
		let{ (iR,iB,jR,jB) in V2} activate3[iR,iB,jR,jB] := if(+x[iR,iB]-x[iR,jB]+x[jR,iB]+x[jR,jB]>2) then 1 else activate3[iR,iB,jR,jB] ;
	else
		let{ (iR,iB,jR,jB) in V2} activate4[iR,iB,jR,jB] := if(-x[iR,iB]+x[iR,jB]+x[jR,iB]+x[jR,jB]>2) then 1 else activate4[iR,iB,jR,jB] ;
}until violated_cuts1+violated_cuts2+violated_cuts3+violated_cuts4 == 0;

display modularity;

set Z := 1..nR cross 1..nB cross 1..nR+nB;
# computing the number of community
var y{1..nR+nB, 1..nR+nB} binary;
# w[i,j,c] = y[i,c] y[j,c]
var z{Z} binary;
fix x;
# display x;


minimize obj:1;

subject to ctr{(i,j) in V1 }: sum{c in 1..nR+nB }z[i,j,c] = x[i,j];
subject to  ll{(i,j,c) in Z }: z[i,j,c]  >= 0;
subject to  uu{(i,j,c) in Z }: z[i,j,c] -y[i,c]-y[nR+j,c] >= -1;
subject to  lu{(i,j,c) in Z }: y[i,c]   -z[i,j,c]  >= 0;
subject to  ul{(i,j,c) in Z }: y[nR+j,c]-z[i,j,c]  >= 0;

solve obj;

# display{(n,c) in 1..nR+nB cross 1..nR+nB : y[n,c]==1} y[n,c];
# display obj;

param verif;
let verif := sum{ c in 1..nR+nB }( sum{(i,j) in E} ( z[i,j,c]*inv_m) - sum{(i,j) in V1} (kR[i]*kB[j]*z[i,j,c]*inv_m*inv_m) );

display verif;
display modularity;