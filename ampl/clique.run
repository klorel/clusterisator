reset;

param instance 				symbolic := include "instance.txt";
param chosen_formulation 	symbolic := include "formulation.txt";

model base.mod;
###
data;
close clique.dat;
printf "set IJ := include ../txt/%s.txt;", instance > clique.dat;
data clique.dat;
###
set FORMULATIONS := {
	"CPI", 
	"CPI_varneg",
	"CPS",
	"CPS2"
};

set CONSTRAINT_FOR_PROBLEM{formulation in FORMULATIONS, kind in 1..3} dimen 3;


let{kind in 1..3} CONSTRAINT_FOR_PROBLEM["CPI", kind ] := V3;
let{kind in 1..3} CONSTRAINT_FOR_PROBLEM["CPI_varneg", kind ] := {(i,j) in V2, k in B: i<j<k};

let CONSTRAINT_FOR_PROBLEM["CPS", 1] := setof{(i,k) in V2, j in Nm[i,k]: i<j<k}(i,j,k);
let CONSTRAINT_FOR_PROBLEM["CPS", 2] := setof{(j,k) in V2, i in Nm[j,k]: i<j<k}(i,j,k);
let CONSTRAINT_FOR_PROBLEM["CPS", 3] := setof{(i,j) in V2, k in Nm[i,j]: i<j<k}(i,j,k);

let CONSTRAINT_FOR_PROBLEM["CPS2", 1] := {(i,j,k) in V3: ( H[i,j]>=0 or H[j,k]>=0)};
let CONSTRAINT_FOR_PROBLEM["CPS2", 2] := {(i,j,k) in V3: ( H[i,j]>=0 or H[i,k]>=0)};
let CONSTRAINT_FOR_PROBLEM["CPS2", 3] := {(i,j,k) in V3: ( H[j,k]>=0 or H[i,k]>=0)};

var t{V2} binary;

maximize modularity: (1/(m))*sum{r in R, b in B}H[r,b]*t[r,b];


subject to constraints{kind in 1..3, (i,j,k) in V3}: 
	+(if kind == 3 then -1 else 1)*t[i,j]
	+(if kind == 2 then -1 else 1)*t[j,k]
	+(if kind == 1 then -1 else 1)*t[i,k]
	<=1;


option solver cplexamp;
 option cplex_options "timing=1 varsel=4 mipdisplay=4 timelimit=3600";
#option cplex_options "timing=1 varsel=4 cutpass=-1 mipdisplay=2";
problem ProblemFormulated:
	modularity, 
	t, 
	{kind in 1..3, (i,j,k) in CONSTRAINT_FOR_PROBLEM[chosen_formulation, kind]}constraints[kind,i,j,k]
	# ,{i in V, j in V diff{i}:chosen_formulation=="CPS"}reflexivity[i,j]
	;


let{i in 1.._ncons}_con[i].lazy := 1;
solve modularity;


include after_solve.run;
